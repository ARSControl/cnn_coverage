# -*- coding: utf-8 -*-
"""limited_gmm_coverage.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QxGJaB967l1S5I9tKI6EjeyRr5WqW_nB

# Coverage control for a MRS with probability density defined by a Gaussian Mixture Model
"""

import numpy as np
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib.pyplot as plt
import random
from shapely import Polygon, Point, intersection
from tqdm import tqdm
from pathlib import Path
import math

from sklearn.mixture import GaussianMixture
from scipy.optimize import minimize
import argparse

from utils import *


def parse_args():
  parser = argparse.ArgumentParser()
  parser.add_argument('--robots-num', type=int,  default=12, help="number of robots")
  parser.add_argument('--obstacles-num', type=int,  default=0, help="number of obstacles")
  parser.add_argument('--range', type=float,  default=3.0, help="sensing range")
  parser.add_argument('--width', type=float,  default=30.0, help="area width")
  args = parser.parse_args()
  return args

def objective_function(u):
  return np.linalg.norm(u)**2

def safety_constraint(u, A, b):
  return -np.dot(A,u) + b


args = parse_args()
ROBOTS_NUM = args.robots_num
ROBOT_RANGE = args.range
TARGETS_NUM = 4
COMPONENTS_NUM = 4
PARTICLES_NUM = 500
OBSTACLES_NUM = args.obstacles_num
AREA_W = args.width
vmax = 1.5
SAFETY_DIST = 2.0
NUM_STEPS = 100
EPISODES = 100
USE_CBF = True if OBSTACLES_NUM > 0 else False
print("ROOBTS NUM : ", ROBOTS_NUM)

path = Path().resolve()

eval_data = np.zeros((EPISODES, NUM_STEPS))
collision_counter = np.zeros((EPISODES, NUM_STEPS))


for episode in range(EPISODES):
  """## Define environment and targets"""

  targets = np.zeros((TARGETS_NUM, 1, 2))
  for i in range(TARGETS_NUM):
    targets[i, 0, 0] = -0.5*(AREA_W-1) + (AREA_W-1) * np.random.rand()
    targets[i, 0, 1] = -0.5*(AREA_W-1) + (AREA_W-1) * np.random.rand()


  """## Define GMM from noisy target measurements"""

  STD_DEV = 2.0
  samples = np.zeros((TARGETS_NUM, PARTICLES_NUM, 2))
  for k in range(TARGETS_NUM):
    for i in range(PARTICLES_NUM):
      samples[k, i, :] = targets[k, 0, :] + STD_DEV * np.random.randn(1, 2)


  # Fit GMM
  samples = samples.reshape((TARGETS_NUM*PARTICLES_NUM, 2))
  print(samples.shape)
  gmm = GaussianMixture(n_components=COMPONENTS_NUM, covariance_type='full', max_iter=1000)
  gmm.fit(samples)

  means = gmm.means_
  covariances = gmm.covariances_
  mix = gmm.weights_

  # print(f"Means: {means}")
  # print(f"Covs: {covariances}")
  # print(f"Mix: {mix}")

  # covariances[0]

  """## Generate probability grid"""

  GRID_STEPS = 64
  s = AREA_W/GRID_STEPS     # step

  xg = np.linspace(-0.5*AREA_W, 0.5*AREA_W, GRID_STEPS)
  yg = np.linspace(-0.5*AREA_W, 0.5*AREA_W, GRID_STEPS)
  Xg, Yg = np.meshgrid(xg, yg)
  Xg.shape

  Z = gmm_pdf(Xg, Yg, means, covariances, mix)
  Z = Z.reshape(GRID_STEPS, GRID_STEPS)
  Z.shape

  Zmax = np.max(Z)
  Z = Z / Zmax

  plot_occgrid(Xg, Yg, Z)

  # ROBOTS_NUM = np.random.randint(6, ROBOTS_MAX)
  converged = False
  points = -0.5*AREA_W + AREA_W * np.random.rand(ROBOTS_NUM, 2)
  robots_hist = np.zeros((1, points.shape[0], points.shape[1]))
  robots_hist[0, :, :] = points
  vis_regions = []
  discretize_precision = 0.5
  dt = 0.25
  GAMMA = 0.2

  # OBSTACLES
  obstacles = np.zeros((OBSTACLES_NUM, 2))
  for i in range(OBSTACLES_NUM):
    done = False
    while not done:
      obstacles[i, :] = -0.5*AREA_W + AREA_W*np.random.rand(1, 2)
      obs_rel = points - obstacles[i]
      norm = np.linalg.norm(obs_rel, axis=1)
      if (norm > 3.0).all():
        done = True   

  r_step = 2 * ROBOT_RANGE / GRID_STEPS
  denom = np.sum(s**2 * gmm_pdf(Xg, Yg, means, covariances, mix))
  print("Total info: ", denom)
  for s in range(1, NUM_STEPS+1):
    # mirror points across each edge of the env
    dummy_points = np.zeros((5*ROBOTS_NUM, 2))
    dummy_points[:ROBOTS_NUM, :] = points
    mirrored_points = mirror(points, AREA_W)
    mir_pts = np.array(mirrored_points)
    dummy_points[ROBOTS_NUM:, :] = mir_pts

    # Voronoi partitioning
    vor = Voronoi(dummy_points)

    conv = True
    lim_regions = []
    img_s = np.zeros((ROBOTS_NUM, GRID_STEPS, GRID_STEPS))
    num = 0.0
    for idx in range(ROBOTS_NUM):
      # Save grid
      p_i = points[idx]
      region = vor.point_region[idx]
      poly_vert = []
      for vert in vor.regions[region]:
        v = vor.vertices[vert]
        poly_vert.append(v)
        # plt.scatter(v[0], v[1], c='tab:red')

      poly = Polygon(poly_vert)
      x,y = poly.exterior.xy
      # plt.plot(x, y, c='tab:orange')
      # robot = np.array([-18.0, -12.0])
      robot = vor.points[idx]

      # plt.scatter(robot[0], robot[1])

      # Intersect with robot range
      step = 0.5
      range_pts = []
      for th in np.arange(0.0, 2*np.pi, step):
        xi = robot[0] + ROBOT_RANGE * np.cos(th)
        yi = robot[1] + ROBOT_RANGE * np.sin(th)
        pt = Point(xi, yi)
        range_pts.append(pt)
        # plt.plot(xi, yi, c='tab:blue')

      range_poly = Polygon(range_pts)
      xc, yc = range_poly.exterior.xy

      lim_region = intersection(poly, range_poly)
      lim_regions.append(lim_region)

      # ------------- EVAL ------------
      neighs = np.delete(vor.points[:ROBOTS_NUM], idx, 0)
      local_pts = neighs - p_i

      # Remove undetected neighbors
      undetected = []
      for i in range(local_pts.shape[0]):
        if local_pts[i, 0] < -ROBOT_RANGE or local_pts[i, 0] > ROBOT_RANGE or local_pts[i, 1] < -ROBOT_RANGE or local_pts[i, 1] > ROBOT_RANGE:
          undetected.append(i)

      local_pts = np.delete(local_pts, undetected, 0)

      region_id = vor.point_region[idx]
      cell = vor.regions[region_id]
      verts = vor.vertices[cell]
      poly = Polygon(verts)
      th = np.arange(0, 2*np.pi+np.pi/20, np.pi/20)
      rng_pts = p_i + ROBOT_RANGE * np.array([np.cos(th), np.sin(th)]).transpose()
      range_poly = Polygon(rng_pts)
      lim_region = intersection(poly, range_poly)

      dA = r_step**2
      for x_i in np.arange(p_i[0]-ROBOT_RANGE, p_i[0]+ROBOT_RANGE, r_step):
        for y_i in np.arange(p_i[1]-ROBOT_RANGE, p_i[1]+ROBOT_RANGE, r_step):
          pt = Point(x_i, y_i)
          if lim_region.contains(pt):
            dA_pdf = dA * gmm_pdf(x_i, y_i, means, covariances, mix)
            num += dA_pdf
      
      # Check collisions
      dist = np.linalg.norm(local_pts, axis=1)
      if (dist < 0.1).any():
        collision_counter[episode, s-1] = 1
        print("Collision detected with neighbors!")
      for obs in obstacles:
        # if p_i[0] > obs[0] - 1.0 and p_i[0] < obs[0] + 1.0 and p_i[1] > obs[1] - 1.0 and p_i[1] < obs[1] + 1.0:
        if np.linalg.norm(p_i-obs) < 0.5*SAFETY_DIST:
          collision_counter[episode, s-1] = 1
          print("Collision detected with obstacle!")


      # Calculate centroid with gaussian distribution
      xmin, ymin, xmax, ymax = lim_region.bounds
      # print(f"x range: {xmin} - {xmax}")
      # print(f"y range: {ymin} - {ymax}")
      A = 0.0
      Cx = 0.0; Cy = 0.0
      dA = discretize_precision ** 2
      # pts = [Point(xmin, ymin), Point(xmax, ymin), Point(xmax, ymax), Point(xmin, ymax)]
      # bound = Polygon(pts)
      for i in np.arange(xmin, xmax, discretize_precision):
        for j in np.arange(ymin, ymax, discretize_precision):
          pt_i = Point(i,j)
          if lim_region.contains(pt_i):
            dA_pdf = dA * gmm_pdf(i, j, means, covariances, mix)
            # print(dA_pdf)
            A = A + dA_pdf
            Cx += i*dA_pdf
            Cy += j*dA_pdf

      Cx = Cx / A
      Cy = Cy / A



      # centr = np.array([lim_region.centroid.x, lim_region.centroid.y])
      centr = np.array([Cx, Cy]).transpose()
      # print(f"Robot: {robot}")
      # print(f"Centroid: {centr}")
      dist = np.linalg.norm(robot-centr)
      vel = 0.8 * (centr - robot)
      vel_i = vel[0, :]
      vel_i[0] = max(-vmax, min(vmax, vel_i[0]))
      vel_i[1] = max(-vmax, min(vmax, vel_i[1]))

      # CBF
      if USE_CBF:
        local_pts = neighs - p_i
        constraints = []
        for n in local_pts:
          h = np.linalg.norm(n)**2 - SAFETY_DIST**2
          A_cbf = 2*n
          b_cbf = GAMMA * h
          constraints.append({'type': 'ineq', 'fun': lambda u: safety_constraint(u, A_cbf, b_cbf)})
        
        local_obs = obstacles - p_i
        for obs in local_obs:
          h = np.linalg.norm(obs)**2 - (SAFETY_DIST)**2
          A_cbf = 2*obs
          b_cbf = GAMMA * h
          constraints.append({'type': 'ineq', 'fun': lambda u: safety_constraint(u, A_cbf, b_cbf)})
        # print("vdes: ", vel_i)
        # print("Acbf: ", A_cbf)
        # print("b_cbf: ", b_cbf)
        # print("h: ", h)
        obj = lambda u: objective_function(u-vel_i)
        res = minimize(obj, vel_i, constraints=constraints, bounds=[(-vmax, vmax), (-vmax, vmax)])
        vel_i = res.x

      points[idx, :] = robot + vel_i*dt
      if np.linalg.norm(vel_i) > 0.15:
        conv = False
      
    eta = num / denom
    eval_data[episode, s-1] = eta[0]

  

    if conv:
      print(f"Converged in {s} iterations")
      break

  print("Eta: ", eta)
  print("Collisions: ", collision_counter[0, :].sum())
  res_path = path / "results"
  np.save(res_path/f"eta{ROBOTS_NUM}_std_{OBSTACLES_NUM}_obs.npy", eval_data)
  np.save(res_path/f"collisions{ROBOTS_NUM}_std_{OBSTACLES_NUM}_obs.npy", collision_counter)



